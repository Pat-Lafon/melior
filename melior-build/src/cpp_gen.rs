//! C++ code generation for dialect registration.

use crate::{Error, tblgen::GenerationOptions, to_class_name};
use std::{fs, path::Path};

/// Generate the C++ registration wrapper file.
///
/// This generates a C++ file that:
/// 1. Includes the mlir-tblgen generated .inc files
/// 2. Implements the dialect's initialize() method
/// 3. Uses MLIR_DEFINE_CAPI_DIALECT_REGISTRATION to expose the C API
pub fn generate_cpp_registration(
    dialect_name: &str,
    cpp_namespace: &str,
    options: &GenerationOptions,
    output_path: &Path,
) -> Result<(), Error> {
    let class_name = to_class_name(dialect_name);

    let type_includes = if options.generate_types {
        format!(
            r#"
#define GET_TYPEDEF_CLASSES
#include "{class_name}Types.h.inc"
"#,
            class_name = class_name
        )
    } else {
        String::new()
    };

    let type_impl_includes = if options.generate_types {
        format!(
            r#"
#define GET_TYPEDEF_CLASSES
#include "{class_name}Types.cpp.inc"
"#,
            class_name = class_name
        )
    } else {
        String::new()
    };

    let attr_includes = if options.generate_attributes {
        format!(
            r#"
#define GET_ATTRDEF_CLASSES
#include "{class_name}Attrs.h.inc"
"#,
            class_name = class_name
        )
    } else {
        String::new()
    };

    let attr_impl_includes = if options.generate_attributes {
        format!(
            r#"
#define GET_ATTRDEF_CLASSES
#include "{class_name}Attrs.cpp.inc"
"#,
            class_name = class_name
        )
    } else {
        String::new()
    };

    let enum_includes = if options.generate_enums {
        format!(
            r#"
#include "{class_name}Enums.h.inc"
"#,
            class_name = class_name
        )
    } else {
        String::new()
    };

    let enum_impl_includes = if options.generate_enums {
        format!(
            r#"
#include "{class_name}Enums.cpp.inc"
"#,
            class_name = class_name
        )
    } else {
        String::new()
    };

    let type_registration = if options.generate_types {
        format!(
            r#"
    addTypes<
#define GET_TYPEDEF_LIST
#include "{class_name}Types.cpp.inc"
    >();"#,
            class_name = class_name
        )
    } else {
        String::new()
    };

    let attr_registration = if options.generate_attributes {
        format!(
            r#"
    addAttributes<
#define GET_ATTRDEF_LIST
#include "{class_name}Attrs.cpp.inc"
    >();"#,
            class_name = class_name
        )
    } else {
        String::new()
    };

    let function_interface_include = if options.use_function_interface {
        "#include \"mlir/Interfaces/FunctionInterfaces.h\"\n".to_string()
    } else {
        String::new()
    };

    let code = format!(
        r#"// Auto-generated by melior-build. Do not edit.

// MLIR C API headers
#include "mlir-c/IR.h"
#include "mlir/CAPI/Registration.h"
#include "mlir/CAPI/Wrap.h"

// Core MLIR headers required for dialect/operation definitions
#include "mlir/IR/Dialect.h"
#include "mlir/IR/DialectImplementation.h"
#include "mlir/IR/OpImplementation.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/BuiltinAttributes.h"

// Additional headers for custom types
#include "llvm/ADT/TypeSwitch.h"

// Common interface headers
#include "mlir/Interfaces/InferTypeOpInterface.h"
{function_interface_include}
// Include generated dialect declaration
#include "{class_name}Dialect.h.inc"
{type_includes}{attr_includes}{enum_includes}
// Include generated operation declarations (after types/attrs so they can use them)
#define GET_OP_CLASSES
#include "{class_name}Ops.h.inc"

// Include generated dialect definition
#include "{class_name}Dialect.cpp.inc"
{type_impl_includes}{attr_impl_includes}{enum_impl_includes}
// Include generated operation definitions
#define GET_OP_CLASSES
#include "{class_name}Ops.cpp.inc"

namespace {cpp_namespace} {{

void {class_name}Dialect::initialize() {{
    addOperations<
#define GET_OP_LIST
#include "{class_name}Ops.cpp.inc"
    >();{type_registration}{attr_registration}
}}

}} // namespace {cpp_namespace}

// C API registration macro - generates mlirGetDialectHandle__{dialect_name}__()
// The extern "C" wrapper ensures the symbol has C linkage for Rust FFI
extern "C" {{
MLIR_DEFINE_CAPI_DIALECT_REGISTRATION({class_name}, {dialect_name}, {cpp_namespace}::{class_name}Dialect)
}}
"#,
        class_name = class_name,
        dialect_name = dialect_name,
        cpp_namespace = cpp_namespace,
        type_includes = type_includes,
        type_impl_includes = type_impl_includes,
        attr_includes = attr_includes,
        attr_impl_includes = attr_impl_includes,
        enum_includes = enum_includes,
        enum_impl_includes = enum_impl_includes,
        type_registration = type_registration,
        attr_registration = attr_registration,
        function_interface_include = function_interface_include,
    );

    fs::write(output_path, code)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Read;

    #[test]
    fn test_generate_cpp_registration() {
        let temp_dir = std::env::temp_dir();
        let output_path = temp_dir.join("test_dialect_capi.cpp");

        let options = GenerationOptions::default();
        generate_cpp_registration("toy", "mlir::toy", &options, &output_path).unwrap();

        let mut content = String::new();
        std::fs::File::open(&output_path)
            .unwrap()
            .read_to_string(&mut content)
            .unwrap();

        assert!(content.contains("ToyDialect.h.inc"));
        assert!(content.contains("ToyDialect.cpp.inc"));
        assert!(content.contains("ToyOps.h.inc"));
        assert!(content.contains("ToyOps.cpp.inc"));
        assert!(content.contains("mlir::toy::ToyDialect"));
        assert!(content.contains("MLIR_DEFINE_CAPI_DIALECT_REGISTRATION(Toy, toy,"));

        // Should not contain type/attr/enum includes when not enabled
        assert!(!content.contains("ToyTypes.h.inc"));
        assert!(!content.contains("ToyAttrs.h.inc"));
        assert!(!content.contains("ToyEnums.h.inc"));

        std::fs::remove_file(&output_path).ok();
    }

    #[test]
    fn test_generate_cpp_registration_with_types() {
        let temp_dir = std::env::temp_dir();
        let output_path = temp_dir.join("test_dialect_with_types_capi.cpp");

        let options = GenerationOptions {
            generate_types: true,
            generate_attributes: false,
            generate_enums: false,
            use_function_interface: false,
        };
        generate_cpp_registration("toy", "mlir::toy", &options, &output_path).unwrap();

        let mut content = String::new();
        std::fs::File::open(&output_path)
            .unwrap()
            .read_to_string(&mut content)
            .unwrap();

        // Should contain type includes
        assert!(content.contains("ToyTypes.h.inc"));
        assert!(content.contains("ToyTypes.cpp.inc"));
        assert!(content.contains("GET_TYPEDEF_CLASSES"));
        assert!(content.contains("GET_TYPEDEF_LIST"));
        assert!(content.contains("addTypes<"));

        // Should not contain attr/enum includes
        assert!(!content.contains("ToyAttrs.h.inc"));
        assert!(!content.contains("ToyEnums.h.inc"));

        std::fs::remove_file(&output_path).ok();
    }

    #[test]
    fn test_generate_cpp_registration_with_all_features() {
        let temp_dir = std::env::temp_dir();
        let output_path = temp_dir.join("test_dialect_full_capi.cpp");

        let options = GenerationOptions {
            generate_types: true,
            generate_attributes: true,
            generate_enums: true,
            use_function_interface: false,
        };
        generate_cpp_registration("my_dialect", "mlir::my_dialect", &options, &output_path)
            .unwrap();

        let mut content = String::new();
        std::fs::File::open(&output_path)
            .unwrap()
            .read_to_string(&mut content)
            .unwrap();

        // Should contain all includes
        assert!(content.contains("MyDialectTypes.h.inc"));
        assert!(content.contains("MyDialectTypes.cpp.inc"));
        assert!(content.contains("MyDialectAttrs.h.inc"));
        assert!(content.contains("MyDialectAttrs.cpp.inc"));
        assert!(content.contains("MyDialectEnums.h.inc"));
        assert!(content.contains("MyDialectEnums.cpp.inc"));

        // Should contain registrations
        assert!(content.contains("addTypes<"));
        assert!(content.contains("addAttributes<"));

        // Should NOT contain FunctionInterfaces header
        assert!(
            !content.contains("FunctionInterfaces.h"),
            "Should not include FunctionInterfaces when disabled"
        );

        std::fs::remove_file(&output_path).ok();
    }

    #[test]
    fn test_generate_cpp_registration_with_function_interface() {
        let temp_dir = std::env::temp_dir();
        let output_path = temp_dir.join("test_dialect_func_interface_capi.cpp");

        let options = GenerationOptions {
            generate_types: false,
            generate_attributes: false,
            generate_enums: false,
            use_function_interface: true,
        };
        generate_cpp_registration("func_dialect", "mlir::func_dialect", &options, &output_path)
            .unwrap();

        let mut content = String::new();
        std::fs::File::open(&output_path)
            .unwrap()
            .read_to_string(&mut content)
            .unwrap();

        // Should contain FunctionInterfaces header
        assert!(
            content.contains("mlir/Interfaces/FunctionInterfaces.h"),
            "Should include FunctionInterfaces.h when enabled"
        );

        // Should NOT contain type/attr/enum includes when disabled
        assert!(!content.contains("FuncDialectTypes.h.inc"));
        assert!(!content.contains("FuncDialectAttrs.h.inc"));
        assert!(!content.contains("FuncDialectEnums.h.inc"));

        std::fs::remove_file(&output_path).ok();
    }
}
