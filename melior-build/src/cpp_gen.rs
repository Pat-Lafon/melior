//! C++ code generation for dialect registration.

use crate::{Error, tblgen::GeneratedFiles, to_class_name};
use std::{fs, path::Path};

/// Generate a simple include line.
fn include(prefix: &str, stem: &str, suffix: &str, ext: &str) -> String {
    format!("#include \"{prefix}{stem}{suffix}.{ext}.inc\"")
}

/// Generate includes with a #define guard (for ops/types/attrs).
fn guarded_include(prefix: &str, stem: &str, suffix: &str, ext: &str, define: &str) -> String {
    format!("#define {define}\n#include \"{prefix}{stem}{suffix}.{ext}.inc\"")
}

/// Generate registration code (addTypes/addAttributes).
fn registration(prefix: &str, stem: &str, suffix: &str, method: &str, list_define: &str) -> String {
    format!(
        r#"
    {method}<
#define {list_define}
#include "{prefix}{stem}{suffix}.cpp.inc"
    >();"#
    )
}

/// Generate the C++ registration wrapper file.
///
/// This generates a C++ file that:
/// 1. Includes the mlir-tblgen generated .inc files
/// 2. Implements the dialect's initialize() method
/// 3. Uses MLIR_DEFINE_CAPI_DIALECT_REGISTRATION to expose the C API
///
/// The `inc_subdir` parameter specifies the subdirectory prefix for .inc includes.
/// For example, if `inc_subdir` is `Some("bril")`, includes become `"bril/BrilOps.h.inc"`.
///
/// File names are based on the TD file stems stored in `generated`, matching MLIR convention.
pub fn generate_cpp_registration(
    dialect_name: &str,
    cpp_namespace: &str,
    generated: &GeneratedFiles,
    inc_subdir: Option<&str>,
    output_path: &Path,
) -> Result<(), Error> {
    let class_name = to_class_name(dialect_name);
    let p = inc_subdir.map(|s| format!("{}/", s)).unwrap_or_default();

    // Dialect includes (simple: {stem}Dialect.h.inc)
    let (dialect_decl_include, dialect_def_include) = generated
        .dialect_stem
        .as_ref()
        .map(|s| {
            (
                include(&p, s, "Dialect", "h"),
                include(&p, s, "Dialect", "cpp"),
            )
        })
        .unwrap_or_default();

    // Ops includes (guarded: GET_OP_CLASSES, {stem}.h.inc - no suffix per MLIR convention)
    let (ops_decl_include, ops_def_include, ops_list_include) = generated
        .ops_stem
        .as_ref()
        .map(|s| {
            (
                guarded_include(&p, s, "", "h", "GET_OP_CLASSES"),
                guarded_include(&p, s, "", "cpp", "GET_OP_CLASSES"),
                guarded_include(&p, s, "", "cpp", "GET_OP_LIST"),
            )
        })
        .unwrap_or_default();

    // Types includes (guarded: GET_TYPEDEF_CLASSES, {stem}Types.h.inc)
    let (type_decl_include, type_def_include, type_registration) = generated
        .types_stem
        .as_ref()
        .map(|s| {
            (
                format!(
                    "\n{}\n",
                    guarded_include(&p, s, "Types", "h", "GET_TYPEDEF_CLASSES")
                ),
                format!(
                    "\n{}\n",
                    guarded_include(&p, s, "Types", "cpp", "GET_TYPEDEF_CLASSES")
                ),
                registration(&p, s, "Types", "addTypes", "GET_TYPEDEF_LIST"),
            )
        })
        .unwrap_or_default();

    // Attrs includes (guarded: GET_ATTRDEF_CLASSES, {stem}Attrs.h.inc)
    let (attr_decl_include, attr_def_include, attr_registration) = generated
        .attrs_stem
        .as_ref()
        .map(|s| {
            (
                format!(
                    "\n{}\n",
                    guarded_include(&p, s, "Attrs", "h", "GET_ATTRDEF_CLASSES")
                ),
                format!(
                    "\n{}\n",
                    guarded_include(&p, s, "Attrs", "cpp", "GET_ATTRDEF_CLASSES")
                ),
                registration(&p, s, "Attrs", "addAttributes", "GET_ATTRDEF_LIST"),
            )
        })
        .unwrap_or_default();

    // Enums includes (simple: {stem}Enums.h.inc)
    let (enum_decl_include, enum_def_include) = generated
        .enums_stem
        .as_ref()
        .map(|s| {
            (
                format!("\n{}\n", include(&p, s, "Enums", "h")),
                format!("\n{}\n", include(&p, s, "Enums", "cpp")),
            )
        })
        .unwrap_or_default();

    let function_interface_include = if generated.use_function_interface {
        "#include \"mlir/Interfaces/FunctionInterfaces.h\"\n"
    } else {
        ""
    };

    let code = format!(
        r#"// Auto-generated by melior-build. Do not edit.

// MLIR C API headers
#include "mlir-c/IR.h"
#include "mlir/CAPI/Registration.h"
#include "mlir/CAPI/Wrap.h"

// Core MLIR headers required for dialect/operation definitions
#include "mlir/IR/Dialect.h"
#include "mlir/IR/DialectImplementation.h"
#include "mlir/IR/OpImplementation.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/BuiltinAttributes.h"

// Additional headers for custom types
#include "llvm/ADT/TypeSwitch.h"

// Common interface headers
#include "mlir/Interfaces/InferTypeOpInterface.h"
{function_interface_include}
// Include generated dialect declaration
{dialect_decl_include}
{type_decl_include}{attr_decl_include}{enum_decl_include}
// Include generated operation declarations (after types/attrs so they can use them)
{ops_decl_include}

// Include generated dialect definition
{dialect_def_include}
{type_def_include}{attr_def_include}{enum_def_include}
// Include generated operation definitions
{ops_def_include}

namespace {cpp_namespace} {{

void {class_name}Dialect::initialize() {{
    addOperations<
{ops_list_include}
    >();{type_registration}{attr_registration}
}}

}} // namespace {cpp_namespace}

// C API registration macro - generates mlirGetDialectHandle__{dialect_name}__()
// The extern "C" wrapper ensures the symbol has C linkage for Rust FFI
extern "C" {{
MLIR_DEFINE_CAPI_DIALECT_REGISTRATION({class_name}, {dialect_name}, {cpp_namespace}::{class_name}Dialect)
}}
"#,
        function_interface_include = function_interface_include,
        dialect_decl_include = dialect_decl_include,
        dialect_def_include = dialect_def_include,
        ops_decl_include = ops_decl_include,
        ops_def_include = ops_def_include,
        ops_list_include = ops_list_include,
        type_decl_include = type_decl_include,
        type_def_include = type_def_include,
        type_registration = type_registration,
        attr_decl_include = attr_decl_include,
        attr_def_include = attr_def_include,
        attr_registration = attr_registration,
        enum_decl_include = enum_decl_include,
        enum_def_include = enum_def_include,
        class_name = class_name,
        dialect_name = dialect_name,
        cpp_namespace = cpp_namespace,
    );

    fs::write(output_path, code)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_generated(
        dialect: Option<&str>,
        ops: Option<&str>,
        types: Option<&str>,
        attrs: Option<&str>,
        enums: Option<&str>,
    ) -> GeneratedFiles {
        GeneratedFiles {
            dialect_stem: dialect.map(String::from),
            ops_stem: ops.map(String::from),
            types_stem: types.map(String::from),
            attrs_stem: attrs.map(String::from),
            enums_stem: enums.map(String::from),
            use_function_interface: false,
        }
    }

    #[test]
    fn test_generate_cpp_registration_single_file() {
        // Simulates a single TD file "ToyOps.td" containing dialect and ops
        let temp_dir = std::env::temp_dir();
        let output_path = temp_dir.join("test_single_file_capi.cpp");

        let generated = make_generated(Some("ToyOps"), Some("ToyOps"), None, None, None);
        generate_cpp_registration("toy", "mlir::toy", &generated, None, &output_path).unwrap();

        let content = std::fs::read_to_string(&output_path).unwrap();

        // MLIR convention: stem + "Dialect.h.inc" for dialect
        assert!(content.contains("ToyOpsDialect.h.inc"));
        assert!(content.contains("ToyOpsDialect.cpp.inc"));
        // MLIR convention: stem + ".h.inc" for ops (no "Ops" suffix added)
        assert!(content.contains("ToyOps.h.inc"));
        assert!(content.contains("ToyOps.cpp.inc"));
        assert!(content.contains("mlir::toy::ToyDialect"));
        assert!(content.contains("MLIR_DEFINE_CAPI_DIALECT_REGISTRATION(Toy, toy,"));

        std::fs::remove_file(&output_path).ok();
    }

    #[test]
    fn test_generate_cpp_registration_multi_file() {
        // Simulates separate TD files: BrilDialect.td, BrilOps.td, BrilTypes.td
        let temp_dir = std::env::temp_dir();
        let output_path = temp_dir.join("test_multi_file_capi.cpp");

        let generated = make_generated(
            Some("BrilDialect"),
            Some("BrilOps"),
            Some("BrilTypes"),
            None,
            None,
        );
        generate_cpp_registration("bril", "mlir::bril", &generated, Some("bril"), &output_path)
            .unwrap();

        let content = std::fs::read_to_string(&output_path).unwrap();

        // Each file's stem is used for its content type
        assert!(content.contains("bril/BrilDialectDialect.h.inc")); // dialect from BrilDialect.td
        assert!(content.contains("bril/BrilOps.h.inc")); // ops from BrilOps.td
        assert!(content.contains("bril/BrilTypesTypes.h.inc")); // types from BrilTypes.td

        std::fs::remove_file(&output_path).ok();
    }

    #[test]
    fn test_generate_cpp_registration_with_all_features() {
        let temp_dir = std::env::temp_dir();
        let output_path = temp_dir.join("test_all_features_capi.cpp");

        let mut generated = make_generated(
            Some("MyOps"),
            Some("MyOps"),
            Some("MyTypes"),
            Some("MyAttrs"),
            Some("MyEnums"),
        );
        generated.use_function_interface = true;

        generate_cpp_registration(
            "my_dialect",
            "mlir::my_dialect",
            &generated,
            None,
            &output_path,
        )
        .unwrap();

        let content = std::fs::read_to_string(&output_path).unwrap();

        // Check all includes use correct stems
        assert!(content.contains("MyOpsDialect.h.inc"));
        assert!(content.contains("MyOps.h.inc"));
        assert!(content.contains("MyTypesTypes.h.inc"));
        assert!(content.contains("MyAttrsAttrs.h.inc"));
        assert!(content.contains("MyEnumsEnums.h.inc"));

        // Check FunctionInterfaces
        assert!(content.contains("mlir/Interfaces/FunctionInterfaces.h"));

        // Check registrations
        assert!(content.contains("addTypes<"));
        assert!(content.contains("addAttributes<"));

        std::fs::remove_file(&output_path).ok();
    }

    #[test]
    fn test_generate_cpp_registration_ops_only() {
        // Test with only ops (no dialect definition in TD files - unusual but possible)
        let temp_dir = std::env::temp_dir();
        let output_path = temp_dir.join("test_ops_only_capi.cpp");

        let generated = make_generated(None, Some("TestOps"), None, None, None);
        generate_cpp_registration("test", "mlir::test", &generated, None, &output_path).unwrap();

        let content = std::fs::read_to_string(&output_path).unwrap();

        // Should have ops includes
        assert!(content.contains("TestOps.h.inc"));
        // Should NOT have dialect includes (empty string)
        assert!(!content.contains("Dialect.h.inc"));

        std::fs::remove_file(&output_path).ok();
    }
}
