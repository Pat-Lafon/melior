//! Rust FFI code generation for dialect registration.

use crate::Error;
use std::{fs, path::Path};

/// Generate the Rust FFI bindings file.
///
/// This generates a Rust file that:
/// 1. Declares the extern "C" function for getting the dialect handle
/// 2. Provides safe wrapper functions for registration
pub fn generate_rust_ffi(dialect_name: &str, output_path: &Path) -> Result<(), Error> {
    let code = format!(
        r#"// Auto-generated by melior-build. Do not edit.

mod {dialect_name}_registration {{
    #[link(name = "{dialect_name}_dialect")]
    unsafe extern "C" {{
        fn mlirGetDialectHandle__{dialect_name}__() -> mlir_sys::MlirDialectHandle;
    }}

    /// Returns the dialect handle for the {dialect_name} dialect.
    ///
    /// This handle can be used to register or load the dialect into a context.
    pub fn dialect_handle() -> ::melior::dialect::DialectHandle {{
        unsafe {{
            ::melior::dialect::DialectHandle::from_raw(mlirGetDialectHandle__{dialect_name}__())
        }}
    }}

    /// Register the {dialect_name} dialect with the given context.
    ///
    /// This makes the dialect available but does not load it. Use `load` if you
    /// want to load the dialect immediately.
    pub fn register(context: &::melior::Context) {{
        dialect_handle().register_dialect(context);
    }}

    /// Load the {dialect_name} dialect into the given context.
    ///
    /// This both registers and loads the dialect, returning the loaded dialect.
    pub fn load(context: &::melior::Context) -> ::melior::dialect::Dialect<'_> {{
        dialect_handle().load_dialect(context)
    }}

    /// Insert the {dialect_name} dialect into a dialect registry.
    ///
    /// This is useful when building a registry to pass to a context.
    pub fn insert_into_registry(registry: &::melior::dialect::DialectRegistry) {{
        dialect_handle().insert_dialect(registry);
    }}
}}

pub use {dialect_name}_registration::{{dialect_handle, insert_into_registry, load, register}};
"#,
        dialect_name = dialect_name,
    );

    fs::write(output_path, code)?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Read;

    #[test]
    fn test_generate_rust_ffi() {
        let temp_dir = std::env::temp_dir();
        let output_path = temp_dir.join("test_register.rs");

        generate_rust_ffi("toy", &output_path).unwrap();

        let mut content = String::new();
        std::fs::File::open(&output_path)
            .unwrap()
            .read_to_string(&mut content)
            .unwrap();

        assert!(content.contains("mlirGetDialectHandle__toy__"));
        assert!(content.contains("pub fn dialect_handle()"));
        assert!(content.contains("pub fn register("));
        assert!(content.contains("pub fn load("));
        assert!(content.contains("pub fn insert_into_registry("));
        assert!(content.contains("::melior::dialect::DialectHandle"));

        std::fs::remove_file(&output_path).ok();
    }
}
